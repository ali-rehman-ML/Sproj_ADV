#! /usr/bin/env python3
import rospy
from nav_msgs.msg import Odometry
from std_msgs.msg import Int32
from tf.transformations import quaternion_from_euler, euler_from_quaternion
from math import sin, cos, pi
import time


rospy.init_node('wheel_odometory')

class wheel_ticks:
    def __init__(self,topic):
        self.ticks=0
        self.delta_ticks=0
        self.topic=topic
        rospy.Subscriber(self.topic, Int32, self.update_left_wheel)

    def up update_countdate_count(self,msg):
        new_ticks=msg.data
        self.delta_ticks=new_ticks-self.ticks
    def get_delta_ticks(self):
        return self.delta_ticks

class Wheel_Odometory:
    def __init__(self):
        self.x=0
        self.y=0
        self.theta=0
        self.curr_time=rospy.get_time()
        self.prev_time=rospy.get_time()
        self.delta_time=0
        self.odomPub = rospy.Publisher('wheel_odom', Odometry, queue_size=10)
        self.odom=Odometry()

        self.left_wheel=wheel_ticks("/chatter1")
        self.right_wheel=wheel_ticks("/chatter2")
        self.odomFrameID='odom'
        self.baseFrameID='base_link'
        self.ticks_per_meter=10
        self.wheel_radius=0.15
        self.wheel_base=1.3
        self.x_velocity=0
        self.y_velocity=0
        self.angular_z=0

        self.rate=rospy.Rate(10)

    def kinematics(self):

        left_displacemnt=(self.left_wheel.get_delta_ticks/self.ticks_per_meter)*(2*pi*self.wheel_radius)
        right_displacemnt=(self.right_wheel.get_delta_ticks/self.ticks_per_meter)*(2*pi*self.wheel_radius)
        self.curr_time=rospy.get_time()
        self.delta_time=self.curr_time-self.prev_time
        self.prev_time=self.curr_time


        deltaTravel = (right_displacemnt + left_displacemnt) / 2
        deltaTheta = (right_displacemnt - left_displacemnt) / self.wheel_base
        deltaX=0
        deltaY=0
        if right_displacemnt == left_displacemnt:
            deltaX = left_displacemnt*cos(self.pose.theta)
            deltaY = left_displacemnt*sin(self.pose.theta)
        else:
            radius = deltaTravel / deltaTheta

            # Find the instantaneous center of curvature (ICC).
            iccX = self.x - radius*sin(self.theta)
            iccY = self.y + radius*cos(self.theta)

            deltaX = cos(deltaTheta)*(self.x - iccX) \
                - sin(deltaTheta)*(self.y - iccY) \
                + iccX - self.x

            deltaY = sin(deltaTheta)*(self.x - iccX) \
                + cos(deltaTheta)*(self.y - iccY) \
                + iccY - self.y
            
        self.x += deltaX
        self.y += deltaY
        self.theta = (self.theta + deltaTheta) % (2*pi)
        self.x_velocity=deltaX/self.delta_time if self.delta_time > 0 else 0
        self.y_velocity=deltaY/self.delta_time if self.delta_time > 0 else 0
        self.angular_z=deltaTheta/self.delta_time if self.delta_time > 0 else 0



    def publish(self):

        while not rospy.is_shutdown():
            self.kinematics()
            odom = Odometry()
            q = quaternion_from_euler(0, 0, self.theta)
            odom.header.stamp = self.curr_time
            odom.header.frame_id = self.odomFrameID
            odom.child_frame_id = self.baseFrameID
            odom.pose.pose.position.x = self.x
            odom.pose.pose.position.y = self.y
            odom.pose.pose.orientation.x = q[0]
            odom.pose.pose.orientation.y = q[1]
            odom.pose.pose.orientation.z = q[2]
            odom.pose.pose.orientation.w = q[3]
            odom.twist.twist.linear.x = self.x_velocity
            odom.twist.twist.linear.y=self.y_velocity
            odom.twist.twist.angular.z = self.angular_z
            self.rate.sleep()

if __name__ == '__main__':
    odom=Wheel_Odometory()
    time.sleep(0.5)
    odom.publish()



        


        

    

        












